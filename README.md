Опа Опа, привет мой маленький читатель, я тут тебе гайдик написал, давай по порядку, да?

Я не буду **вываливать** на тебя весь огромный мой код, а сейчас его с самого начала разберём. 

```c
#include <stdio.h>
#include <string.h>
```

Надеюсь что такое [<stdio.h>] мне объяснять не нужно? :)

а во про [<string.h>] поподробнее:
Хотя чего тут подробнее? это библиотека для обработки строк, так как я решил сие задание именно таким способом, то и думать нечего более, узнаем на практике.

# Часть 1

Для начала мы объявим 3 переменных, которые помогут нам в работе, хотя правильнее будет назвать их "функции":
``` c
int coding_ASCII(char *str);
int decoding_ASCII(char *str);
int hex_dec(char symb);
```

1, как понятно из названия, будет кодировать в ASCII
2, как понятно из названия, будет декодировать из ASCII в нормальный текст
3, как не очень понятно из названия, будет использовать HEX(16ти-ричную систему исчисления), для кодировки.

На этом часть 1 - закончили.

# Часть 2

Давай проанализируем вот такой блок кода:
```c
int main(int argc, char **argv)
{
    if (argc != 2) {
        printf("Usage: %s <mode>\n", argv[0]);
        return 1;
    }
    char str[100];
    fgets(str, sizeof str, stdin);
    str[strcspn(str, "\n")] = 0; // Удаляем символ новой строки, который добавляется функцией fgets
    if (strcmp(argv[1], "0") == 0) {
        if (coding_ASCII(str) == -1) return -1;
    } else if (strcmp(argv[1], "1") == 0) {
        if (decoding_ASCII(str) == -1) return -1;
    } else {
        printf("Invalid mode\n");
        return 1;
    }
    return 0;
}
```

Ух ёп, сразу так много, с чего бы начать...

С начала конечно?...?....?...!"

```c
int main(int argc, char **argv)
```

↑ тут происходит инициализация переменной и массива для ввода ↑

``` c
{
    if (argc != 2) {
        printf("Usage: %s <mode>\n", argv[0]);
        return 1;
    }
```

Вот тут происходит проверка аргументов, аргументов при вводе в консоль должны быть **2**
1) 0/1 кодировка/декодировка
2) слово/хекс для обработки

в случи непредоставления двух аргументов - будет выведена соответствующая строка, указанная после [printf].
[return 1] нужен чтобы вернуть код на стадию ввода, в случаи если не указаны все аргументы.

дальше будет действовать чуть медленнее:
``` c
char str[100];
```
 ↑ тут мы указываем, что длинная слова в массиве не должна превышать 100 символов


``` c
fgets(str, sizeof str, stdin);
```

с помощью такой команды, по аналогии со [scanf], мы вытягиваем из ввода массив [str], указываем что его размер меньше или равен указанной выше переменной 100 [sizeof str], и после добавляем [stdin], что данные для ввода взяты как аргументы в терминале.

``` c
str[strcspn(str, "\n")] = 0;
```
Удаляем символ новой строки, который добавляется функцией fgets


``` c
 if (strcmp(argv[1], "0") == 0) {
        if (coding_ASCII(str) == -1) return -1;
    } else if (strcmp(argv[1], "1") == 0) {
        if (decoding_ASCII(str) == -1) return -1;
    } else {
        printf("Invalid mode\n");
        return 1;
    }
```

собственно - прогоняем полученные данные через все **Функции** которые будем разбирать дальше.

``` c
return 0;
```

не знаю зачем это в конце писать, наверное чтобы получить мороженко, шутка :)

# Часть 2: кодируем в Асю(ASCII)

``` c
int coding_ASCII(char *str)
```

Инициализируем функцию, которую создали до мейна, указываем что это массив и [* str] как ссылка на переменную.

дальше нужна новая переменная, для вычислений внутри функции:
``` c
int i;
```

а теперь сама функция for:

``` c
for (i = 0; str[i] != '\0'; i++) {
        if (i % 2 == 1 && str[i] != ' ') {
            printf("n/a\n");
            return -1;
        }
```
изначально [i] = 0, после используем массив i который не равен ['\\0'], которое обозначает "конец строк", так же её называют "нулевой терминатор". 

``` c
if (i % 2 == 1 && str[i] != ' ')
```
если при делении остаток будет равен 1 и позиция i в массиве будет являться пробелом - то функция выкинет число обратно, чтобы выдать n/a.


так же тут прописывается вторая функция:

``` c
for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') printf(" ");
        else printf("%x", str[i]);
    }
```

если в массиве str на позиции i  будет пробел - то в строку добавится пробел, если нет, то будет выведен символ из массива str.

```c
printf("\n");
```

обязательно добавить в конце.

``` c
return 0;
```

и не забыть команду на получение мороженки.


# Часть 3: Декодинг Аси(ASCII)

Так же, как и в предыдущем случаи, обращение к массиву:
```c
int decoding_ASCII(char *str)
```
тут нам для расчёта понадобится уже 2 переменные:
```c
int i, x;
```

циклы тут, будут похожи на предыдущие, но словно "вверх ногами":

```c
for (i = 0; str[i] != '\0'; i++) {
        if ((i+2) % 3 == 1 && str[i] != ' ') {
            printf("n/a\n");
            return -1;
```

Честно признаться, не знаю что тут можно объяснить словами, это просто математика...

А вот второй цикл в этой функции уже будет посложнее:

```c
for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') {
            printf(" ");
        } else {
            x = hex_dec(str[i]) * 0x10 + hex_dec(str[i+1]);
            printf("%c", x);
            i++;
        }
    }
```

он уже будет напрямую обращаться к следующей функции, которую я планировал описать далее, но лучше скину тоже сразу:

```c
int hex_dec(char symb) 
{
    if (symb >= '0' && symb <= '9') return symb - '0';
    if (symb >= 'A' && symb <= 'F') return symb - 'A' + 10;
    if (symb >= 'a' && symb <= 'f') return symb - 'a' + 10;
    
    return 0; // Возвращаем 0 для недопустимых символов
}
```

кодировка ASCII по сути набор букв + ЧИСЛОxЧИСЛО

поэтому эти 2 функции перебирают символы от и до, расставляя их в зависимости от чисел в массиве str, а также добавляют [10точки] к [0x10].

А теперь давайте рассмотрим весь код разом:

``` c
#include <stdio.h>
#include <string.h>
int coding_ASCII(char *str);
int decoding_ASCII(char *str);
int hex_dec(char symb);
int main(int argc, char **argv)
{
    if (argc != 2) {
        printf("Usage: %s <mode>\n", argv[0]);
        return 1;
    }
    char str[100];
    fgets(str, sizeof str, stdin);
    str[strcspn(str, "\n")] = 0; // Удаляем символ новой строки, который добавляется функцией fgets
    if (strcmp(argv[1], "0") == 0) {
        if (coding_ASCII(str) == -1) return -1;
    } else if (strcmp(argv[1], "1") == 0) {
        if (decoding_ASCII(str) == -1) return -1;
    } else {
        printf("Invalid mode\n");
        return 1;
    }
    return 0;
}
int coding_ASCII(char *str) 
{
    int i;
    for (i = 0; str[i] != '\0'; i++) {
        if (i % 2 == 1 && str[i] != ' ') {
            printf("n/a\n");
            return -1;
        }
    }
    
    for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') printf(" ");
        else printf("%x", str[i]);
    }
    
    printf("\n");
    return 0;
}
int decoding_ASCII(char *str) 
{
    int i, x;
    for (i = 0; str[i] != '\0'; i++) {
        if ((i+2) % 3 == 1 && str[i] != ' ') {
            printf("n/a\n");
            return -1;
        }
    }
    
    for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') {
            printf(" ");
        } else {
            x = hex_dec(str[i]) * 0x10 + hex_dec(str[i+1]);
            printf("%c", x);
            i++;
        }
    }
    printf("\n");
    return 0;
}
int hex_dec(char symb) 
{
    if (symb >= '0' && symb <= '9') return symb - '0';
    if (symb >= 'A' && symb <= 'F') return symb - 'A' + 10;
    if (symb >= 'a' && symb <= 'f') return symb - 'a' + 10;
    
    return 0; // Возвращаем 0 для недопустимых символов
}
```

К сожалению, я не могу описать всё ещё более красиво, но надеюсь мой мини-гайд вам помог! <3 <3 <3 
